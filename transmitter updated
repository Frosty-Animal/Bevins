#include <xc.h>
#include <stdio.h>
#include <string.h>

#define _XTAL_FREQ 16000000
#define BAUD_RATE 115200

// -----------------------------------------------------------------
// UART and RN4020 Bluetooth Module Pin Definitions
// -----------------------------------------------------------------
// RN4020 connections:
//   - TX (from RN4020) → PIC RX on RB5
//   - RX (to RN4020)   → PIC TX on RB7
//   - CTS (from RN4020) is driven by PIC on RB4 (set high)
//   - RTS (from RN4020) is read on PIC RB6
//   - WAKE_HW (to RN4020) is driven high on RC2
#define UART_TX_TRIS    TRISB7
#define UART_RX_TRIS    TRISB5
#define CTS_PIN         LATB4
#define CTS_TRIS        TRISB4
#define RN4020_RTS      PORTBbits.RB6
#define WAKE_HW         LATC2
#define WAKE_HW_TRIS    TRISC2

// -----------------------------------------------------------------
// Local Sensor & Switch Definitions
// -----------------------------------------------------------------
// Local potentiometer (for sensor data) on PIC pin 11; assume RA2 (AN2)
#define LOCAL_POT_CHANNEL  2      // AN2
#define POT_TRIS           TRISAbits.TRISA2

// Local mode switch on PIC pin 19; assume RA5 (active low)
#define SWITCH_PIN         PORTAbits.RA5
#define SWITCH_TRIS        TRISAbits.TRISA5

// -----------------------------------------------------------------
// LED Definitions
// -----------------------------------------------------------------
// Status LED (for general status) remains on PIC pin 4 (assume RC3)
// Link indicator LED is now on PIC pin 2, which maps to RC5 per the datasheet.
#define STATUS_LED_PIN     LATCbits.LATC3
#define STATUS_LED_TRIS    TRISCbits.TRISC3

#define LINK_LED_PIN       LATCbits.LATC5  // RC5 used as link indicator (pin 2)
#define LINK_LED_TRIS      TRISCbits.TRISC5

// LED control functions (for status LED)
void LED_On(void) {
    STATUS_LED_PIN = 1;
}
void LED_Off(void) {
    STATUS_LED_PIN = 0;
}
void LED_Toggle(void) {
    STATUS_LED_PIN = !STATUS_LED_PIN;
}

// -----------------------------------------------------------------
// Global Variable for Link Indicator Timeout
// -----------------------------------------------------------------
volatile unsigned char linkTimeout = 0; // Refreshed when a valid RF packet is received

// -----------------------------------------------------------------
// Function Prototypes
// -----------------------------------------------------------------
void UART_Init(void);
void UART_Write(char data);
char UART_Read(void);
void UART_SendString(const char* str);
void WaitFor_RN4020_RTS(void);
void ADC_Init(void);
unsigned int readLocalPot(void);
void RN4020_SendCommand(const char* cmd, char* responseBuffer, unsigned int timeout);

// -----------------------------------------------------------------
// Main Function
// -----------------------------------------------------------------
void main(void) {
    char response[30] = {0};

    // Initialize peripherals
    UART_Init();
    ADC_Init();

    // Configure the switch as digital input (active low)
    SWITCH_TRIS = 1;
    
    // Configure LED outputs:
    STATUS_LED_TRIS = 0;  // Status LED (RC3) as output
    LED_Off();            // Turn status LED off initially
    
    LINK_LED_TRIS = 0;    // Link indicator LED (RC5) as output
    LINK_LED_PIN = 0;     // Start with link LED off

    // Configure RN4020 control pins
    WAKE_HW_TRIS = 0;
    WAKE_HW = 1;         // Drive WAKE_HW high to wake RN4020
    
    CTS_TRIS = 0;
    CTS_PIN = 1;         // Drive CTS high
    
    __delay_ms(100);     // Allow RN4020 to power up
    
    // Enter command mode: send "$$$"
    UART_SendString("$$$");
    LED_Toggle();        // Toggle status LED to indicate command mode entry
    __delay_ms(100);
    
    // Optionally, read the response (expected "CMD")
    RN4020_SendCommand("", response, 500);
    // (Response check can be added if desired)
    
    // Send a configuration command (example: set device name)
    RN4020_SendCommand("SN,Transmitter", response, 500);
    __delay_ms(100);
    
    // Exit command mode (example command, see RN4020 datasheet)
    RN4020_SendCommand("C", response, 500);
    __delay_ms(100);
    
    // Indicate transmitter is ready
    UART_SendString("Transmitter Ready\r\n");
    LED_On();  // Turn on status LED
    
    // Refresh link indicator on startup
    linkTimeout = 50;
    
    while (1) {
        // Update link indicator:
        if (linkTimeout > 0) {
            linkTimeout--;      // Decrement timeout counter
            LINK_LED_PIN = 1;   // Turn link LED on (link active)
        } else {
            LINK_LED_PIN = 0;   // Turn link LED off (link lost)
        }
        
        // If the local mode switch is pressed, read the pot and send its value
        if (SWITCH_PIN == 0) {  // Active low: switch pressed
            unsigned int potValue = readLocalPot();
            char dataBuffer[30];
            sprintf(dataBuffer, "POT:%u\r\n", potValue);
            UART_SendString(dataBuffer);
            LED_Toggle();       // Optionally toggle status LED
            linkTimeout = 50;   // Refresh link indicator on valid transmission
        }
        __delay_ms(500);
    }
}

// -----------------------------------------------------------------
// UART Functions
// -----------------------------------------------------------------
void UART_Init(void) {
    // Configure UART TX (RB7) as output and RX (RB5) as input
    UART_TX_TRIS = 0;
    UART_RX_TRIS = 1;
    
    // Set up UART for 115200 baud
    SPBRG = ((_XTAL_FREQ / (16UL * BAUD_RATE)) - 1);
    TXSTA = 0b00100100;  // TX enabled, BRGH = 1 (high speed)
    RCSTA = 0b10010000;  // Serial port enabled, continuous receive
    TXEN = 1;
    SPEN = 1;
}

void WaitFor_RN4020_RTS(void) {
    // Wait until RN4020's RTS (RB6) indicates readiness (active high)
    while (RN4020_RTS == 0) {
        // Optionally add a short delay here
    }
}

void UART_Write(char data) {
    WaitFor_RN4020_RTS();
    while (!TXIF);
    TXREG = data;
}

char UART_Read(void) {
    while (!RCIF);
    return RCREG;
}

void UART_SendString(const char* str) {
    while (*str) {
        UART_Write(*str++);
    }
}

// -----------------------------------------------------------------
// ADC Functions for Local Potentiometer (AN2 on RA2)
// -----------------------------------------------------------------
void ADC_Init(void) {
    // Enable analog function on RA2 (bit 2 of ANSELA) for the local potentiometer
    ANSELA |= 0x04;  // 0x04 sets AN2 as analog
    // Configure ADC: right justified, Fosc/32, Vref = VDD.
    ADCON1 = 0xA0;
    ADCON2 = 0x00; // Manual trigger
}

unsigned int readLocalPot(void) {
    // Select channel for local pot (AN2)
    ADCON0 = (LOCAL_POT_CHANNEL << 2);
    ADCON0bits.ADON = 1;              // Turn on ADC
    __delay_us(10);                   // Acquisition time
    ADCON0bits.GO_nDONE = 1;          // Start conversion
    while (ADCON0bits.GO_nDONE);      // Wait for conversion
    unsigned int result = ((unsigned int)ADRESH << 8) | ADRESL;
    return result;
}

// -----------------------------------------------------------------
// RN4020 Command Function
// -----------------------------------------------------------------
void RN4020_SendCommand(const char* cmd, char* responseBuffer, unsigned int timeout) {
    if (strlen(cmd) > 0) {
        UART_SendString(cmd);
        UART_Write('\r');
    }
    unsigned int timer = 0;
    unsigned int idx = 0;
    responseBuffer[0] = '\0';  // Clear response buffer
    while (timer < timeout) {
        if (RCIF) {
            char ch = UART_Read();
            responseBuffer[idx++] = ch;
            responseBuffer[idx] = '\0';
            if (ch == '\n') break;  // End of response
        }
        __delay_ms(1);
        timer++;
    }
    if (strlen(responseBuffer) > 0) {
        linkTimeout = 50;  // Refresh link indicator timeout if response received
    }
}
