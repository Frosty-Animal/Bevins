#include <xc.h>
#include <stdio.h>

// Configuration: assume a 16MHz clock and 115200 baud UART
#define _XTAL_FREQ 16000000
#define BAUD_RATE 115200

// -----------------------------------------------------------------
// UART and Bluetooth Module Pin Definitions
// -----------------------------------------------------------------
// RN4020 connections:
//   - RN4020 TX -> PIC RX on RB5
//   - RN4020 RX -> PIC TX on RB7
//   - CTS (from RN4020) is driven by PIC on RB4
//   - RTS (from RN4020) is read on PIC RB6
//   - WAKE_HW is driven high on RC2
#define UART_TX_TRIS    TRISB7
#define UART_RX_TRIS    TRISB5
#define CTS_PIN         LATB4
#define CTS_TRIS        TRISB4
#define RN4020_RTS      PORTBbits.RB6
#define WAKE_HW         LATC2
#define WAKE_HW_TRIS    TRISC2

// -----------------------------------------------------------------
// Motor Control (A3941 Full Bridge) Pin Definitions
// -----------------------------------------------------------------
// Driver reset connection:
//   - PIC pin 13 (RC0) goes to driver reset (pin 24)
//   - A 20kΩ pull-down resistor is connected on the driver side.
#define DRIVER_RESET         LATC0    // PIC RC0 (pin 13)
#define DRIVER_RESET_TRIS    TRISC0

// PWM mapping for the full-bridge driver:
//   - PIC PWM1 (assumed on RA0) drives the driver’s PWMH (pin 23)
//   - PIC PWM2 (assumed on RA1) drives the driver’s PWML (pin 22)
#define PWMH_DUTY    PWM1DCH
#define PWML_DUTY    PWM2DCH
#define PWMH_TRIS    TRISAbits.TRISA0   // PIC PWM1 output (e.g., RA0)
#define PWML_TRIS    TRISAbits.TRISA1   // PIC PWM2 output (e.g., RA1)

// -----------------------------------------------------------------
// Fault Flag Definitions
// -----------------------------------------------------------------
// Fault Flag 1 is connected to PIC RC4 (original ProFLEX designated FAULT pin)
#define FAULT_FLAG1         PORTCbits.RC4
#define FAULT_FLAG1_TRIS    TRISCbits.TRISC4

// -----------------------------------------------------------------
// Function Prototypes
// -----------------------------------------------------------------
void UART_Init(void);
void UART_Write(char data);
char UART_Read(void);
void UART_SendString(const char* str);
void WaitFor_RN4020_RTS(void);

void Motor_Init(void);
void setMotorSpeedDirection(unsigned char speed, unsigned char direction);
void checkFaultFlag(void);

// -----------------------------------------------------------------
// Main Function
// -----------------------------------------------------------------
void main(void) {
    UART_Init();    // Initialize UART and Bluetooth control pins
    Motor_Init();   // Initialize motor control pins and PWM outputs

    // Initially, hold the driver in reset.
    DRIVER_RESET = 0;
    __delay_ms(100); // Allow time for proper reset condition

    // Bring the driver out of reset.
    DRIVER_RESET = 1;

    __delay_ms(100);
    UART_SendString("$$$");   // Command to put RN4020 into command mode
    __delay_ms(100);

    // Example: Set motor speed and direction.
    // 'speed' is a value (0-255) representing the PWM duty cycle.
    // 'direction' is 0 for forward and 1 for reverse.
    setMotorSpeedDirection(128, 0); // 50% duty cycle, forward direction

    while (1) {
        // Check the fault flag periodically.
        checkFaultFlag();
        
        // For demonstration, echo received UART characters.
        char received = UART_Read();
        UART_Write(received);
    }
}

// -----------------------------------------------------------------
// UART Functions
// -----------------------------------------------------------------
void UART_Init(void) {
    // Configure UART TX and RX pins:
    UART_TX_TRIS = 0;  // Set RB7 as output (TX)
    UART_RX_TRIS = 1;  // Set RB5 as input (RX)

    // Configure WAKE_HW: Set RC2 as output and drive it high.
    WAKE_HW_TRIS = 0;
    WAKE_HW = 1;

    // Configure CTS: Set RB4 as output and drive high.
    CTS_TRIS = 0;
    CTS_PIN = 1;

    // Configure RN4020 RTS: Set RB6 as input.
    TRISB6 = 1;

    // Set up UART for 115200 baud.
    SPBRG = ((_XTAL_FREQ / (16UL * BAUD_RATE)) - 1);
    TXSTA = 0b00100100;  // Transmit enabled, BRGH = 1 (high-speed)
    RCSTA = 0b10010000;  // Serial port enabled, continuous receive enabled

    TXEN = 1;  // Enable transmitter
    SPEN = 1;  // Enable serial port
}

void WaitFor_RN4020_RTS(void) {
    // Wait until the RN4020 indicates it is ready to receive data.
    while (RN4020_RTS == 0) {
        // Optionally add a small delay if needed.
    }
}

void UART_Write(char data) {
    WaitFor_RN4020_RTS();  // Ensure RN4020 is ready
    while (!TXIF);         // Wait for TX buffer to be free
    TXREG = data;          // Transmit the data
}

char UART_Read(void) {
    while (!RCIF);         // Wait for data reception
    return RCREG;          // Return received data
}

void UART_SendString(const char* str) {
    while (*str) {
        UART_Write(*str++);
    }
}

// -----------------------------------------------------------------
// Motor Control Functions
// -----------------------------------------------------------------
void Motor_Init(void) {
    // Configure the driver reset pin (RC0, PIC pin 13) as output.
    DRIVER_RESET_TRIS = 0;
    // Initially hold the driver in reset.
    DRIVER_RESET = 0;
    
    // Configure PWM output pins as outputs.
    PWMH_TRIS = 0;
    PWML_TRIS = 0;
    
    // Initialize PWM duty cycles to 0.
    PWMH_DUTY = 0;
    PWML_DUTY = 0;
    
    // Configure the fault flag pin as input.
    FAULT_FLAG1_TRIS = 1;
    
    // (Note: Ensure that the PWM module is configured separately as required.)
}

void setMotorSpeedDirection(unsigned char speed, unsigned char direction) {
    // For forward motion (direction = 0): drive PWMH with the specified speed and hold PWML at 0.
    // For reverse (direction = 1): drive PWML with the specified speed and hold PWMH at 0.
    if (direction == 0) {  // Forward
        PWMH_DUTY = speed;
        PWML_DUTY = 0;
    } else {               // Reverse
        PWMH_DUTY = 0;
        PWML_DUTY = speed;
    }
}

// -----------------------------------------------------------------
// Fault Flag Monitoring Function
// -----------------------------------------------------------------
void checkFaultFlag(void) {
    // Assuming the fault flag is active low:
    if (FAULT_FLAG1 == 0) {
        // Fault detected. Disable motor outputs and hold the driver in reset.
        PWMH_DUTY = 0;
        PWML_DUTY = 0;
        DRIVER_RESET = 0;  // Optionally hold the driver in reset.
        UART_SendString("FAULT DETECTED\r\n");
        
        // Wait here until the fault is cleared.
        while (FAULT_FLAG1 == 0) {
            __delay_ms(100);
        }
        
        // Fault cleared; bring the driver out of reset.
        DRIVER_RESET = 1;
        UART_SendString("FAULT CLEARED\r\n");
    }
}
