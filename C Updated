#include <xc.h>
#include <stdio.h>

// Configuration: assume a 16MHz clock and 115200 baud UART
#define _XTAL_FREQ 16000000
#define BAUD_RATE 115200

// -----------------------------------------------------------------
// UART and Bluetooth Module Pin Definitions
// -----------------------------------------------------------------
// RN4020 connections:
//   - RN4020 TX -> PIC RX on RB5
//   - RN4020 RX -> PIC TX on RB7
//   - CTS (from RN4020) is driven by PIC on RB4
//   - RTS (from RN4020) is read on PIC RB6
//   - WAKE_HW is driven high on RC2
#define UART_TX_TRIS    TRISB7
#define UART_RX_TRIS    TRISB5
#define CTS_PIN         LATB4
#define CTS_TRIS        TRISB4
#define RN4020_RTS      PORTBbits.RB6
#define WAKE_HW         LATC2
#define WAKE_HW_TRIS    TRISC2

// -----------------------------------------------------------------
// Motor Control (A3941 Full Bridge) Pin Definitions
// -----------------------------------------------------------------
// Driver reset connection:
//   - PIC pin 13 (RC0) -> driver reset (pin 24)
#define DRIVER_RESET         LATC0    // PIC RC0 (pin 13)
#define DRIVER_RESET_TRIS    TRISC0

// PWM mapping for the full-bridge driver:
//   - PIC PWM1 (assumed on RA0) -> driver’s PWMH (pin 23)
//   - PIC PWM2 (assumed on RA1) -> driver’s PWML (pin 22)
#define PWMH_DUTY    PWM1DCH
#define PWML_DUTY    PWM2DCH
#define PWMH_TRIS    TRISAbits.TRISA0   // PIC PWM1 output (RA0)
#define PWML_TRIS    TRISAbits.TRISA1   // PIC PWM2 output (RA1)

// -----------------------------------------------------------------
// Fault Flag Definitions
// -----------------------------------------------------------------
// Fault Flag 1 is connected to PIC RC4
#define FAULT_FLAG1         PORTCbits.RC4
#define FAULT_FLAG1_TRIS    TRISCbits.TRISC4

// -----------------------------------------------------------------
// Battery Voltage Monitoring
// ----------------------------------------------------------------
// Battery is measured on RA4 (pin 20), configured as AN3
#define BATTERY_ADC_CHANNEL 3

// -----------------------------------------------------------------
// Local Switch & Potentiometer
// ----------------------------------------------------------------
// Switch on PIC pin 19 (assume RA5). Active low: 0 = pressed
#define SWITCH_PIN          PORTAbits.RA5
#define SWITCH_TRIS         TRISAbits.TRISA5

// On-board pot on PIC pin 11 (assume RA2), configured as AN2
#define LOCAL_POT_CHANNEL   2

// -----------------------------------------------------------------
// Function Prototypes
// -----------------------------------------------------------------
void UART_Init(void);
void UART_Write(char data);
char UART_Read(void);
void UART_SendString(const char* str);
void WaitFor_RN4020_RTS(void);

void Motor_Init(void);
void setMotorSpeedDirection(unsigned char speed, unsigned char direction);
void checkFaultFlag(void);

void ADC_Init(void);
unsigned int readBattery(void);
void checkBattery(void);

unsigned int readLocalPot(void);
void checkLocalPot(void);

void main(void) {
    // Initialize all subsystems
    UART_Init();    
    Motor_Init();   
    ADC_Init();     

    // Configure the switch pin (RA5) as a digital input
    SWITCH_TRIS = 1;  

    // Initially, hold the driver in reset.
    DRIVER_RESET = 0;
    __delay_ms(100); // time for proper reset

    // Bring the driver out of reset
    DRIVER_RESET = 1;

    __delay_ms(100);
    UART_SendString("$$$");  // Put RN4020 in command mode (example)
    __delay_ms(100);

    // Example: initial motor setting
    setMotorSpeedDirection(128, 0); // 50% duty cycle, forward

    while (1) {
        // Check for a fault condition
        checkFaultFlag();

        // Check battery voltage and send reading
        checkBattery();

        // Check if switch is pressed and read pot if so
        checkLocalPot();

        // Echo any received UART characters (for demo)
        char received = UART_Read();
        UART_Write(received);

        __delay_ms(500); // main loop delay
    }
}

// -----------------------------------------------------------------
// UART Functions
// -----------------------------------------------------------------
void UART_Init(void) {
    // Configure TX and RX
    UART_TX_TRIS = 0;  // RB7 as output (TX)
    UART_RX_TRIS = 1;  // RB5 as input (RX)

    // WAKE_HW: RC2 as output, drive high
    WAKE_HW_TRIS = 0;
    WAKE_HW = 1;

    // CTS: RB4 as output, drive high
    CTS_TRIS = 0;
    CTS_PIN = 1;

    // RTS: RB6 as input
    TRISB6 = 1;

    // Setup 115200 baud
    SPBRG = ((_XTAL_FREQ / (16UL * BAUD_RATE)) - 1);
    TXSTA = 0b00100100;  // TX enable, BRGH=1 (high speed)
    RCSTA = 0b10010000;  // Serial port enable, continuous receive
    TXEN = 1;            
    SPEN = 1;            
}

void WaitFor_RN4020_RTS(void) {
    // Wait until RN4020 indicates it's ready
    while (RN4020_RTS == 0) {
        // Optional small delay
    }
}

void UART_Write(char data) {
    WaitFor_RN4020_RTS();  
    while (!TXIF);        
    TXREG = data;         
}

char UART_Read(void) {
    while (!RCIF);        
    return RCREG;         
}

void UART_SendString(const char* str) {
    while (*str) {
        UART_Write(*str++);
    }
}

// -----------------------------------------------------------------
// Motor Control Functions
// -----------------------------------------------------------------
void Motor_Init(void) {
    // Driver reset pin (RC0)
    DRIVER_RESET_TRIS = 0;
    DRIVER_RESET = 0;

    // PWM outputs
    PWMH_TRIS = 0;
    PWML_TRIS = 0;

    // Zero duty cycles
    PWMH_DUTY = 0;
    PWML_DUTY = 0;

    // Fault flag pin
    FAULT_FLAG1_TRIS = 1;
}

void setMotorSpeedDirection(unsigned char speed, unsigned char direction) {
    // direction=0 => forward => drive PWMH, zero PWML
    // direction=1 => reverse => drive PWML, zero PWMH
    if (direction == 0) {
        PWMH_DUTY = speed;
        PWML_DUTY = 0;
    } else {
        PWMH_DUTY = 0;
        PWML_DUTY = speed;
    }
}

void checkFaultFlag(void) {
    // Assume fault flag is active low
    if (FAULT_FLAG1 == 0) {
        // Fault => disable motor, reset driver
        PWMH_DUTY = 0;
        PWML_DUTY = 0;
        DRIVER_RESET = 0;
        UART_SendString("FAULT DETECTED\r\n");

        // Wait for fault to clear
        while (FAULT_FLAG1 == 0) {
            __delay_ms(100);
        }
        // Restore driver
        DRIVER_RESET = 1;
        UART_SendString("FAULT CLEARED\r\n");
    }
}

// -----------------------------------------------------------------
// ADC / Battery Voltage Functions
// -----------------------------------------------------------------
void ADC_Init(void) {
    // Example: RA4 -> AN3 for battery, RA2 -> AN2 for local pot
    // Enable analog on RA4 (bit 4) and RA2 (bit 2) in ANSELA
    // For instance: RA2 is bit 2, RA4 is bit 4 => 0x14 = b00010100
    ANSELA |= 0x14;

    // Right justified, Fosc/32, Vref=VDD
    ADCON1 = 0xA0;
    ADCON2 = 0x00; // Manual trigger
}

unsigned int readBattery(void) {
    // Battery on AN3 => RA4
    ADCON0 = (BATTERY_ADC_CHANNEL << 2);
    ADCON0bits.ADON = 1;
    __delay_us(10);
    ADCON0bits.GO_nDONE = 1;
    while(ADCON0bits.GO_nDONE);
    unsigned int result = ((unsigned int)ADRESH << 8) | ADRESL;
    return result;
}

void checkBattery(void) {
    unsigned int adcVal = readBattery();
    float voltage = adcVal * (3.3 / 1023.0);
    char buffer[30];
    sprintf(buffer, "Battery: %.2fV\r\n", voltage);
    UART_SendString(buffer);
}

// -----------------------------------------------------------------
// Local Pot Reading (Pin 11 -> RA2 -> AN2)
// -----------------------------------------------------------------
unsigned int readLocalPot(void) {
    // Local pot on AN2 => RA2
    ADCON0 = (LOCAL_POT_CHANNEL << 2);
    ADCON0bits.ADON = 1;
    __delay_us(10);
    ADCON0bits.GO_nDONE = 1;
    while (ADCON0bits.GO_nDONE);
    return ((unsigned int)ADRESH << 8) | ADRESL;
}

// -----------------------------------------------------------------
// Check Local Pot: If switch is pressed, read pot for motor speed
// -----------------------------------------------------------------
void checkLocalPot(void) {
    // Switch is active low => 0 means pressed
    if (SWITCH_PIN == 0) {
        unsigned int potVal = readLocalPot();
        // potVal is 0..1023 from ADC
        // Convert to 0..255 for duty cycle
        unsigned char speed = (unsigned char)(potVal >> 2);

        // For demo, always forward direction when using local pot
        setMotorSpeedDirection(speed, 0);
    } else {
        // Switch not pressed => optionally do nothing or stop motor
        // setMotorSpeedDirection(0, 0);
    }
}
