#include <xc.h>
#include <stdio.h>
#include <string.h>

#define _XTAL_FREQ 16000000
#define BAUD_RATE 115200

// -----------------------------------------------------------------
// UART and RN4020 Bluetooth Module Pin Definitions
// -----------------------------------------------------------------
// RN4020 connections:
//   - RN4020 TX -> PIC RX on RB5
//   - RN4020 RX -> PIC TX on RB7
//   - CTS (from RN4020) is driven by PIC on RB4
//   - RTS (from RN4020) is read on PIC RB6
//   - WAKE_HW (to RN4020) is now driven high on RC6 (PIC pin 5)
#define UART_TX_TRIS    TRISB7
#define UART_RX_TRIS    TRISB5
#define CTS_PIN         LATB4
#define CTS_TRIS        TRISB4
#define RN4020_RTS      PORTBbits.RB6
#define WAKE_HW         LATC6           // WAKE_HW now on RC6 (pin 5)
#define WAKE_HW_TRIS    TRISC6          // TRISC6 for WAKE_HW

// -----------------------------------------------------------------
// Motor Control (A3941 Full Bridge) Pin Definitions
// -----------------------------------------------------------------
// Driver reset connection:
//   - PIC pin 13 (RC0) -> driver reset (pin 24)
#define DRIVER_RESET         LATC0    // PIC RC0 (pin 13)
#define DRIVER_RESET_TRIS    TRISC0

// PWM mapping for the full-bridge driver:
//   - PIC PWM1 (assumed on RA0) -> driver’s PWMH (pin 23)
//   - PIC PWM2 (assumed on RA1) -> driver’s PWML (pin 22)
#define PWMH_DUTY    PWM1DCH
#define PWML_DUTY    PWM2DCH
#define PWMH_TRIS    TRISAbits.TRISA0   // PIC PWM1 output (RA0)
#define PWML_TRIS    TRISAbits.TRISA1   // PIC PWM2 output (RA1)

// -----------------------------------------------------------------
// Phase Pin Definition for Driver
// -----------------------------------------------------------------
// The driver's Phase input is connected to PIC pin 12 (RC1). We need it always on.
#define PHASE_PIN      LATC1
#define PHASE_TRIS     TRISC1

// -----------------------------------------------------------------
// Fault Flag Definitions
// -----------------------------------------------------------------
// Fault Flag 1 is connected to PIC RC4
#define FAULT_FLAG1         PORTCbits.RC4
#define FAULT_FLAG1_TRIS    TRISCbits.TRISC4

// -----------------------------------------------------------------
// Battery Voltage Monitoring
// -----------------------------------------------------------------
// Battery is measured on RA4 (pin 20), configured as AN3
#define BATTERY_ADC_CHANNEL 3

// -----------------------------------------------------------------
// Local Switch & Potentiometer for Testing
// -----------------------------------------------------------------
// Switch on PIC pin 19 (assume RA5). Active low: 0 = pressed
#define SWITCH_PIN          PORTAbits.RA5
#define SWITCH_TRIS         TRISAbits.TRISA5

// On-board pot on PIC pin 11 (assume RA2), configured as AN2
#define LOCAL_POT_CHANNEL   2

// -----------------------------------------------------------------
// Function Prototypes
// -----------------------------------------------------------------
void UART_Init(void);
void UART_Write(char data);
char UART_Read(void);
void UART_SendString(const char* str);
void WaitFor_RN4020_RTS(void);

void Motor_Init(void);
void setMotorSpeedDirection(unsigned char speed, unsigned char direction);
void checkFaultFlag(void);

void ADC_Init(void);
unsigned int readBattery(void);
void checkBattery(void);

unsigned int readLocalPot(void);
void checkLocalPot(void);

void processReceivedData(const char *data);

void main(void) {
    // Initialize all subsystems
    UART_Init();    
    Motor_Init();   
    ADC_Init();     

    // Configure the switch pin (RA5) as a digital input
    SWITCH_TRIS = 1;  

    // Initially, hold the driver in reset.
    DRIVER_RESET = 0;
    __delay_ms(100); // time for proper reset

    // Bring the driver out of reset
    DRIVER_RESET = 1;

    // Configure the Phase pin (connected to driver's Phase input) on RC1:
    PHASE_TRIS = 0;  // Set RC1 as output
    PHASE_PIN = 1;   // Drive RC1 high (Phase always on)

    __delay_ms(100);
    UART_SendString("$$$");  // Put RN4020 in command mode (example)
    __delay_ms(100);

    // Example: initial motor setting (for testing, here using local pot signal)
    setMotorSpeedDirection(128, 0); // 50% duty cycle, forward

    while (1) {
        checkFaultFlag();
        checkBattery();

        // If the test switch is pressed, use the on-board potentiometer
        if (SWITCH_PIN == 0) {
            checkLocalPot();
        } else {
            // Otherwise, check for received data from the transmitter
            // Use a non-blocking approach: if data is available, process it.
            if (RCIF) {
                char receivedBuffer[50] = {0};
                unsigned char idx = 0;
                // Read available characters until newline or buffer full
                while (RCIF && (idx < sizeof(receivedBuffer) - 1)) {
                    char ch = UART_Read();
                    receivedBuffer[idx++] = ch;
                    if (ch == '\n') break;
                }
                receivedBuffer[idx] = '\0';
                processReceivedData(receivedBuffer);
            }
        }

        __delay_ms(500);
    }
}

// -----------------------------------------------------------------
// UART Functions
// -----------------------------------------------------------------
void UART_Init(void) {
    // Configure TX and RX
    UART_TX_TRIS = 0;  // RB7 as output (TX)
    UART_RX_TRIS = 1;  // RB5 as input (RX)

    // WAKE_HW: now on RC6 as output, drive high
    WAKE_HW_TRIS = 0;
    WAKE_HW = 1;

    // CTS: RB4 as output, drive high
    CTS_TRIS = 0;
    CTS_PIN = 1;

    // RTS: RB6 as input
    TRISB6 = 1;

    // Setup 115200 baud
    SPBRG = ((_XTAL_FREQ / (16UL * BAUD_RATE)) - 1);
    TXSTA = 0b00100100;  // TX enabled, BRGH = 1 (high speed)
    RCSTA = 0b10010000;  // Serial port enabled, continuous receive
    TXEN = 1;            
    SPEN = 1;            
}

void WaitFor_RN4020_RTS(void) {
    // Wait until RN4020 indicates it's ready
    while (RN4020_RTS == 0) {
        // Optional small delay
    }
}

void UART_Write(char data) {
    WaitFor_RN4020_RTS();  
    while (!TXIF);        
    TXREG = data;         
}

char UART_Read(void) {
    while (!RCIF);        
    return RCREG;         
}

void UART_SendString(const char* str) {
    while (*str) {
        UART_Write(*str++);
    }
}

// -----------------------------------------------------------------
// Motor Control Functions
// -----------------------------------------------------------------
void Motor_Init(void) {
    // Driver reset pin (RC0)
    DRIVER_RESET_TRIS = 0;
    DRIVER_RESET = 0;

    // PWM outputs
    PWMH_TRIS = 0;
    PWML_TRIS = 0;

    // Zero duty cycles
    PWMH_DUTY = 0;
    PWML_DUTY = 0;

    // Fault flag pin
    FAULT_FLAG1_TRIS = 1;
}

void setMotorSpeedDirection(unsigned char speed, unsigned char direction) {
    // direction=0 => forward => drive PWMH, zero PWML
    // direction=1 => reverse => drive PWML, zero PWMH
    if (direction == 0) {
        PWMH_DUTY = speed;
        PWML_DUTY = 0;
    } else {
        PWMH_DUTY = 0;
        PWML_DUTY = speed;
    }
}

void checkFaultFlag(void) {
    // Assume fault flag is active low
    if (FAULT_FLAG1 == 0) {
        // Fault => disable motor, reset driver
        PWMH_DUTY = 0;
        PWML_DUTY = 0;
        DRIVER_RESET = 0;
        UART_SendString("FAULT DETECTED\r\n");

        // Wait for fault to clear
        while (FAULT_FLAG1 == 0) {
            __delay_ms(100);
        }
        // Restore driver
        DRIVER_RESET = 1;
        UART_SendString("FAULT CLEARED\r\n");
    }
}

// -----------------------------------------------------------------
// ADC / Battery Voltage Functions
// -----------------------------------------------------------------
void ADC_Init(void) {
    // Enable analog on RA4 (for battery, AN3) and RA2 (for local pot, AN2)
    // RA2 is bit 2 and RA4 is bit 4 => 0x14 = b00010100
    ANSELA |= 0x14;

    // Right justified, Fosc/32, Vref=VDD
    ADCON1 = 0xA0;
    ADCON2 = 0x00; // Manual trigger
}

unsigned int readBattery(void) {
    // Battery on AN3 => RA4
    ADCON0 = (BATTERY_ADC_CHANNEL << 2);
    ADCON0bits.ADON = 1;
    __delay_us(10);
    ADCON0bits.GO_nDONE = 1;
    while (ADCON0bits.GO_nDONE);
    unsigned int result = ((unsigned int)ADRESH << 8) | ADRESL;
    return result;
}

void checkBattery(void) {
    unsigned int adcVal = readBattery();
    float voltage = adcVal * (3.3 / 1023.0);
    char buffer[30];
    sprintf(buffer, "Battery: %.2fV\r\n", voltage);
    UART_SendString(buffer);
}

// -----------------------------------------------------------------
// Local Pot Reading (On-board pot on RA2 -> AN2)
// -----------------------------------------------------------------
unsigned int readLocalPot(void) {
    ADCON0 = (LOCAL_POT_CHANNEL << 2);
    ADCON0bits.ADON = 1;
    __delay_us(10);
    ADCON0bits.GO_nDONE = 1;
    while (ADCON0bits.GO_nDONE);
    return ((unsigned int)ADRESH << 8) | ADRESL;
}

// -----------------------------------------------------------------
// Check Local Pot: Used when switch is pressed for testing
// -----------------------------------------------------------------
void checkLocalPot(void) {
    // Switch is active low => 0 means pressed
    if (SWITCH_PIN == 0) {
        unsigned int potVal = readLocalPot();
        // Convert the 10-bit pot value (0..1023) to 0..255 for PWM duty cycle
        unsigned char speed = (unsigned char)(potVal >> 2);
        // For local testing, we assume forward direction (direction = 0)
        setMotorSpeedDirection(speed, 0);
        char buf[30];
        sprintf(buf, "Local Pot: %u\r\n", speed);
        UART_SendString(buf);
    }
}

// -----------------------------------------------------------------
// Process Received Data from the Transmitter
// -----------------------------------------------------------------
void processReceivedData(const char *data) {
    int duty;
    char dirStr[4]; // to hold "FWD" or "REV"
    
    // Expecting data in the format: "DC:<duty>, DIR:<dir>\r\n"
    if (sscanf(data, "DC:%d, DIR:%3s", &duty, dirStr) == 2) {
        unsigned char directionVal = (strcmp(dirStr, "REV") == 0) ? 1 : 0;
        // Optionally, map or clamp duty if needed before using it
        setMotorSpeedDirection((unsigned char)duty, directionVal);
        
        // For debugging, print the parsed values
        char buf[50];
        sprintf(buf, "Parsed: DC=%d, DIR=%s\r\n", duty, (directionVal==1 ? "REV" : "FWD"));
        UART_SendString(buf);
    } else {
        UART_SendString("Invalid data received\r\n");
    }
}
