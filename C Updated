#include <xc.h>
#include <stdio.h>

// Configuration: assume a 16MHz clock and 115200 baud UART
#define _XTAL_FREQ 16000000
#define BAUD_RATE 115200

// -----------------------------------------------------------------
// UART and Bluetooth Module Pin Definitions
// -----------------------------------------------------------------
// RN4020 connections:
//   - RN4020 TX -> PIC RX on RB5
//   - RN4020 RX -> PIC TX on RB7
//   - CTS (from RN4020) is driven by PIC on RB4
//   - RTS (from RN4020) is read on PIC RB6
//   - WAKE_HW is driven high on RC2
#define UART_TX_TRIS    TRISB7
#define UART_RX_TRIS    TRISB5
#define CTS_PIN         LATB4
#define CTS_TRIS        TRISB4
#define RN4020_RTS      PORTBbits.RB6
#define WAKE_HW         LATC2
#define WAKE_HW_TRIS    TRISC2

// -----------------------------------------------------------------
// Motor Control (A3941 Full Bridge) Pin Definitions
// -----------------------------------------------------------------
// Driver reset connection:
//   - PIC pin 13 (RC0) goes to driver reset (pin 24)
//   - A 20kΩ pull-down resistor is connected on the driver side.
#define DRIVER_RESET         LATC0    // PIC RC0 (pin 13)
#define DRIVER_RESET_TRIS    TRISC0

// PWM mapping for the full-bridge driver:
//   - PIC PWM1 (assumed on RA0) drives the driver’s PWMH (pin 23)
//   - PIC PWM2 (assumed on RA1) drives the driver’s PWML (pin 22)
#define PWMH_DUTY    PWM1DCH
#define PWML_DUTY    PWM2DCH
#define PWMH_TRIS    TRISAbits.TRISA0   // PIC PWM1 output (e.g., RA0)
#define PWML_TRIS    TRISAbits.TRISA1   // PIC PWM2 output (e.g., RA1)

// -----------------------------------------------------------------
// Fault Flag Definitions
// -----------------------------------------------------------------
// Fault Flag 1 is connected to PIC RC4 (per original schematic)
#define FAULT_FLAG1         PORTCbits.RC4
#define FAULT_FLAG1_TRIS    TRISCbits.TRISC4

// -----------------------------------------------------------------
// Battery Voltage Monitoring Definitions
// -----------------------------------------------------------------
// Battery voltage is measured on RA4 (PIC pin 20), configured as AN3.
#define BATTERY_ADC_CHANNEL 3   // RA4 is AN3

// -----------------------------------------------------------------
// Function Prototypes
// -----------------------------------------------------------------
void UART_Init(void);
void UART_Write(char data);
char UART_Read(void);
void UART_SendString(const char* str);
void WaitFor_RN4020_RTS(void);

void Motor_Init(void);
void setMotorSpeedDirection(unsigned char speed, unsigned char direction);
void checkFaultFlag(void);

void ADC_Init(void);
unsigned int readBattery(void);
void checkBattery(void);

void main(void) {
    UART_Init();    // Initialize UART and Bluetooth control pins
    Motor_Init();   // Initialize motor control pins, PWM outputs, and fault flag input
    ADC_Init();     // Initialize ADC for battery voltage measurement

    // Initially, hold the driver in reset.
    DRIVER_RESET = 0;
    __delay_ms(100); // Allow time for proper reset condition

    // Bring the driver out of reset.
    DRIVER_RESET = 1;

    __delay_ms(100);
    UART_SendString("$$$");   // Command to put RN4020 into command mode
    __delay_ms(100);

    // Example: Set motor speed and direction.
    setMotorSpeedDirection(128, 0); // 50% duty cycle, forward direction

    while (1) {
        // Check for a fault condition.
        checkFaultFlag();
        
        // Check battery voltage and send reading over UART.
        checkBattery();
        
        // For demonstration, echo any received UART characters.
        char received = UART_Read();
        UART_Write(received);
        
        __delay_ms(500); // Delay between iterations
    }
}

// -----------------------------------------------------------------
// UART Functions
// -----------------------------------------------------------------
void UART_Init(void) {
    // Configure UART TX and RX pins.
    UART_TX_TRIS = 0;  // RB7 as output (TX)
    UART_RX_TRIS = 1;  // RB5 as input (RX)
    
    // Configure WAKE_HW: Set RC2 as output and drive it high.
    WAKE_HW_TRIS = 0;
    WAKE_HW = 1;
    
    // Configure CTS: Set RB4 as output and drive it high.
    CTS_TRIS = 0;
    CTS_PIN = 1;
    
    // Configure RN4020 RTS: Set RB6 as input.
    TRISB6 = 1;
    
    // Set up UART for 115200 baud.
    SPBRG = ((_XTAL_FREQ / (16UL * BAUD_RATE)) - 1);
    TXSTA = 0b00100100;  // TX enabled, BRGH = 1 (high speed)
    RCSTA = 0b10010000;  // Serial port enabled, continuous receive enabled
    TXEN = 1;            // Enable transmitter
    SPEN = 1;            // Enable serial port
}

void WaitFor_RN4020_RTS(void) {
    // Wait until the RN4020 indicates it is ready.
    while (RN4020_RTS == 0) {
        // Optionally, add a small delay here.
    }
}

void UART_Write(char data) {
    WaitFor_RN4020_RTS();  // Ensure RN4020 is ready
    while (!TXIF);         // Wait until TX buffer is free
    TXREG = data;          // Transmit data
}

char UART_Read(void) {
    while (!RCIF);         // Wait for data reception
    return RCREG;          // Return the received character
}

void UART_SendString(const char* str) {
    while (*str) {
        UART_Write(*str++);
    }
}

// -----------------------------------------------------------------
// Motor Control Functions
// -----------------------------------------------------------------
void Motor_Init(void) {
    // Configure the driver reset pin (RC0, PIC pin 13) as an output.
    DRIVER_RESET_TRIS = 0;
    // Initially hold the driver in reset.
    DRIVER_RESET = 0;
    
    // Configure PWM output pins as outputs.
    PWMH_TRIS = 0;
    PWML_TRIS = 0;
    
    // Initialize PWM duty cycles to 0.
    PWMH_DUTY = 0;
    PWML_DUTY = 0;
    
    // Configure the fault flag pin as an input.
    FAULT_FLAG1_TRIS = 1;
}

void setMotorSpeedDirection(unsigned char speed, unsigned char direction) {
    // For forward motion (direction = 0): drive PWMH and set PWML to 0.
    // For reverse (direction = 1): drive PWML and set PWMH to 0.
    if (direction == 0) {  // Forward
        PWMH_DUTY = speed;
        PWML_DUTY = 0;
    } else {               // Reverse
        PWMH_DUTY = 0;
        PWML_DUTY = speed;
    }
}

void checkFaultFlag(void) {
    // Assuming Fault Flag is active low:
    if (FAULT_FLAG1 == 0) {
        // Fault detected—disable motor outputs and hold the driver in reset.
        PWMH_DUTY = 0;
        PWML_DUTY = 0;
        DRIVER_RESET = 0;
        UART_SendString("FAULT DETECTED\r\n");
        
        // Wait until the fault flag is cleared.
        while (FAULT_FLAG1 == 0) {
            __delay_ms(100);
        }
        
        // Fault cleared; bring the driver out of reset.
        DRIVER_RESET = 1;
        UART_SendString("FAULT CLEARED\r\n");
    }
}

// -----------------------------------------------------------------
// ADC / Battery Voltage Functions
// -----------------------------------------------------------------
void ADC_Init(void) {
    // Enable analog function on RA4 (bit 4 of ANSELA) for battery voltage.
    ANSELA |= 0x10;
    // Configure ADC: right justified, Fosc/32, Vref = Vdd.
    ADCON1 = 0xA0;
    ADCON2 = 0x00; // Manual trigger.
}

unsigned int readBattery(void) {
    // Select channel for RA4 (AN3) by shifting the channel number into ADCON0.
    ADCON0 = (BATTERY_ADC_CHANNEL << 2);  // Bits 2-5 for channel selection.
    ADCON0bits.ADON = 1;                   // Turn on the ADC.
    __delay_us(10);                        // Acquisition time.
    ADCON0bits.GO_nDONE = 1;               // Start conversion.
    while(ADCON0bits.GO_nDONE);            // Wait for conversion to finish.
    unsigned int result = ((unsigned int)ADRESH << 8) | ADRESL;
    return result;
}

void checkBattery(void) {
    unsigned int adcValue = readBattery();
    // Assuming a 10-bit ADC (0-1023) with Vref = 3.3V.
    float voltage = adcValue * (3.3 / 1023.0);
    char buffer[30];
    sprintf(buffer, "Battery: %.2fV\r\n", voltage);
    UART_SendString(buffer);
}

